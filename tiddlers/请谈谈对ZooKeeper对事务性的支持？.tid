created: 20220524073734214
creator: Yangqing QU
difficulty: 3.473165602361763
due: 20221220130047241
grade: 0
history: [{"due":"20220529141916061","interval":0,"difficulty":2.9854211216321387,"stability":0.21875,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220528141916061"},{"due":"20220603004738309","interval":5,"difficulty":3.275394598109508,"stability":0.0960748629946603,"retrievability":0.08997347647736906,"grade":0,"lapses":1,"reps":1,"review":"20220602004738309"},{"due":"20220618120656584","interval":4,"difficulty":1.4878375526797638,"stability":11.844090543980142,"retrievability":0.012442954570255769,"grade":2,"lapses":1,"reps":2,"review":"20220606120656584"},{"due":"20220806014308798","interval":13,"difficulty":1.578630691712205,"stability":48.17999104683492,"retrievability":0.8907931390324411,"grade":1,"lapses":1,"reps":3,"review":"20220619014308797"},{"due":"20220810040833118","interval":51,"difficulty":2.6730976270178677,"stability":0.054881164580531924,"retrievability":0.8944669353056625,"grade":0,"lapses":2,"reps":1,"review":"20220809040833118"},{"due":"20220815080625670","interval":5,"difficulty":2.873165425642418,"stability":0.040656966333775045,"retrievability":0.00006779862455024804,"grade":0,"lapses":3,"reps":1,"review":"20220814080625670"},{"due":"20220821143545286","interval":6,"difficulty":3.073165602361762,"stability":0.03011942145770373,"retrievability":1.7671934421049204e-7,"grade":0,"lapses":4,"reps":1,"review":"20220820143545286"},{"due":"20220831140625476","interval":10,"difficulty":3.273165602361763,"stability":0.02231301621225883,"retrievability":6.426555450991425e-16,"grade":0,"lapses":5,"reps":1,"review":"20220830140625475"}]
interval: 111
lapses: 6
modified: 20221219130047241
modifier: Yangqing QU
reps: 1
retrievability: 2.351601321531264e-228
review: 20221219130047241
stability: 0.3305977764431731
tags: zookeeper ?
title: 请谈谈对ZooKeeper对事务性的支持？
type: text/vnd.tiddlywiki

https://www.51cto.com/article/606200.html

```
分布式事务的基础

从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:

CAP

CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。

C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。

A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。

P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。

对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。

对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。

顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。
```
```
BASE

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展

基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。

软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。

最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。

BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。
```
```
分布式事务解决方案

有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。

是否真的要分布式事务

在说方案之前，首先你一定要明确你是否真的需要分布式事务?

上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。

如果你确定需要引入分布式事务可以看看下面几种常见的方案。

2PC

说到2PC就不得不聊数据库分布式事务中的 XA Transactions。
```
[img[关于Zookeeper的分布式事务，我写了全网最详细的解读2022-08-30 21_50_25.jpg]]

```
在XA协议中分为两阶段:

第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。

缺点:

单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。
总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。

TCC

关于TCC(Try-Confirm-Cancel)的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点:

1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。

3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

......
```