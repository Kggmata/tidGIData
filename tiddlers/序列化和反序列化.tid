created: 20220607004801864
difficulty: 1
due: 20220920142332991
grade: 2
history: [{"due":"20220611003818906","interval":0,"difficulty":1.2687524673440806,"stability":0.1037109375,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220610003818906"},{"due":"20220629112708397","interval":3,"difficulty":1,"stability":15.693018113617368,"retrievability":0.04746718678804762,"grade":2,"lapses":0,"reps":2,"review":"20220613112708397"}]
interval: 18
lapses: 0
modified: 20220701142332991
reps: 3
retrievability: 0.8861675498643524
review: 20220701142332991
stability: 81.1468944767812
tags: hbase ?
title: 序列化和反序列化
type: text/vnd.tiddlywiki

https://segmentfault.com/a/1190000038311368#:~:text=%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A%E5%B0%B1%E6%98%AF%E5%B0%86%E5%AF%B9%E8%B1%A1,%E5%92%8C%E5%8E%9F%E6%9D%A5%E4%B8%80%E6%A8%A1%E4%B8%80%E6%A0%B7%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82

序列化：就是将对象转化成字节序列的过程。

反序列化：就是讲字节序列转化成对象的过程。

''对象序列化成的字节序列会包含对象的类型信息、对象的数据等''，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。

二、为什么
那么为什么要去进行序列化呢？有以下两个原因

持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。

网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。
