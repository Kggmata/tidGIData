created: 20220724141235354
difficulty: 0.02337100302925359
due: 20220906004725534
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220905004725534
reps: 1
retrievability: 1
review: 20220905004725534
stability: 0.10000000088475645
tags: flink ?
title: 什么是字节码?好处?
type: text/vnd.tiddlywiki

```
JVM能够理解的代码就是字节码(即扩展名为.class的文件).
它不面向任何特定的处理器,只面向虚拟机.
java通过字节码的方式, 一定程度解决了传统解释型语言执行效率低的问题.同时也保留了解释型语言能够移植的特点. (但是和C++, Rust, Go等语言还是有一定差距)
字节码并不针对特定的机器, 因此无需重新编译, 便可以在不同的操作系统的计算机上运行.
```
[img[Java程序转变为机器代码的过程2022-07-24 22_18_29.png]]

```
在.class->机器码这一步, JVM类加载器首先加载字节码文件, 然后解释器逐行解释执行. 这种执行方式较慢, 但是有些方法和代码块是经常需要倍调用的(热点代码). 所以, 后面引进了JIT(Just-in-time compilation)编译器, JIT属于运行时编译. 当JIT编译器完成第一次编译之后, 会将字节码对应的机器码保存下来. 下次可以直接调用. 机器码的运行效率肯定是高于java解释器的. 因此这就是为什么java是解释与编译并存的语言
```
```
HotSpot采用了lazy evaluation的做法. 根据二八定律, 消耗大部分资源的仅仅是那一小部分代码. 而这也是JIT所需要编译的部分. JVM会根据代码每次被执行的情况收集信息并相应的做出一些优化. 因此执行的次数越多, 速度就越快. JDK9引入了一种新的编译模式AOT(Ahead of Time Compilation), 它将直接将字节码编译成机器码. 这样就避免了JIT预热等各方面的开销. JDK支持分层编译和AOT协作使用
```