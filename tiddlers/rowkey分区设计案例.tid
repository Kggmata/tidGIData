created: 20220606113429626
difficulty: 1.0684973211750646
due: 20221002001623737
grade: 1
history: [{"due":"20220611003349433","interval":0,"difficulty":1.2687524673440806,"stability":0.1037109375,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220610003349433"},{"due":"20220629235143590","interval":3,"difficulty":1,"stability":15.693018113617368,"retrievability":0.04746718678804762,"grade":2,"lapses":0,"reps":2,"review":"20220613235143590"}]
interval: 21
lapses: 0
modified: 20220705001623737
reps: 3
retrievability: 0.8684973211750646
review: 20220705001623737
stability: 88.53436204041341
tags: hbase ?
title: rowkey分区设计案例
type: text/vnd.tiddlywiki

*实例1

需要使用Rowkey的数据，都是数字，是杂乱无章的数字（0,1,2,3,4,5,6,7,8,9 随机开头）

假设划分10个Region，那么可以简单的：

```shell
create 't', 'c', {SPLITS => ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']}
```

假设划分100个Region，那么可以简单的：

```shell
create 't', 'c', {SPLITS => ['00', '01', '02'...,'11', '12', '13', ...'98', '99']}
```

*实例2

需要使用Rowkey的数据，都是字母，是杂乱无章的英文字母开头，（a、b、c等随机）

如果是英文字母，我们一般是 26个分区、260个分区这种套路划分

> 大小写需要考虑
>
> 如果是大小写混合的，我们可以通过写入前，进行处理全部转小写或大写来写入HBase
>
> 然后找一个二级列，存储其原本大小写分明的原始Rowkey既可

```shell
create 't', 'c', {SPLITS => ['a', 'b', 'c', ...,'x', 'y', 'z']}
```

*实例3

需要使用Rowkey的数据，都是手机号，如何设计？

将手机号：`反转`存入即可

分区应用：0~9的分区设置就行

查询的时候，用反转的手机号查询即可。



*实例4

同样是手机号，或者是那种天然难以分区的数据

将其Hash取值，或者说通过MD5加密

它们能变成16进制的字符串

比如：

- 18500002222 经过MD5后，可以得到：`61d8a07f4ae23d429b3bd5de575b00a2`
- 18500001111 经过MD5后，可以得到: `1c933a8e447732fcc23fc2f83bb07fd3`

> MD5和Hash
>
> 只要MD5和Hash的算法没有更改（参数固定）
>
> 无论加密多少次，同一个数据得到的都是同一个结果

比如MD5加密后，就可以应用HBase提供的`HexStringSplit（16进制字符串）`自动分区功能。

```shell
create 't1', 'f1', {NUMREGIONS => 100, SPLITALGO => 'HexStringSplit'}
```



查询的时候，将明文数据，再次MD5或Hash计算后，拿计算结果去查即可。

比如：18500002222 存入HBase 是：61d8a07f4ae23d429b3bd5de575b00a2

查询的时候，再次计算18500002222，得到61d8a07f4ae23d429b3bd5de575b00a2查询即可



*总结

> 规划分区，主要就是确保写入的数据是分散的，这样压力比较分散到各个服务器上。

