created: 20220728031835383
modified: 20230102012832558
modifier: Yangqing QU
tags: ? stream实时/flink
title: doris物化视图自动选择
type: text/vnd.tiddlywiki

[img[BillfishjkhuQN2022-07-28 11_18_55.PNG]]

```
这里分为两个步骤：
	对候选集合进行一个过滤。只要是查询的结果能从物化视图数据计算（取部分行，部分列，或部分行列的聚合）出都可以留在候选集中，过滤完成后候选集合大小 >= 1。
	从候选集合中根据聚合程度，索引等条件选出一个最优的也就是查询花费最少物化视图。
这里再举一个相对复杂的例子，来体现这个过程。
```
[img[BillfishEIeYwl2022-07-28 11_19_13.PNG]]

```
首先先说过滤候选集这个过程。
候选集过滤目前分为4层，每一层过滤后去除不满足条件的物化视图。
例如：查询2月10日各个销售员都买了多少钱。
	首先候选集中包括所有的物化视图以及Base表共4个。
	第一层过滤先判断查询Where中的谓词涉及到的数据是否能从物化视图中得到，也就是销售时间列是否在表中存在。由于第三个物化视图中根本不存在销售时间列。所以在这一层过滤中，mv_3就被淘汰了。
	第二层是过滤查询的分组列是否为候选集的分组列的子集，也就是销售员id是否为表中分组列的子集。由于第二个物化视图中的分组列并不涉及销售员id。所以在这一层过滤中，mv_2也被淘汰了。
	第三层过滤是看查询的聚合列是否为候选集中聚合列的子集，也就是对销售额求和是否能从候选集的表中聚合得出。这里Base表和物化视图表均满足标准。
	最后一层是过滤看查询需要的列是否存在于候选集合的列中。由于候选集合中的表均满足标准，所以最终候选集合中的表为销售明细表，以及mv_1这两张。
候选集过滤完后输出一个集合，这个集合中的所有表都能满足查询的需求，但每张表的查询效率都不同。
这时候就需要在这个集合根据前缀索引是否能匹配到，以及聚合程度的高低来选出一个最优的物化视图。
例如：从表结构中可以看出，Base表的销售日期列是一个非排序列，而物化视图表的日期是一个排序列，同时聚合程度上mv_1表明显比Base表高。
所以最后选择出mv_1作为该查询的最优匹配。

```