created: 20220717030727126
difficulty: 2.0303734468904295
due: 20220903055617626
grade: 0
history: [{"due":"20220727065408199","interval":0,"difficulty":0.07897385645727227,"stability":0.10000011324882507,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220726065408199"},{"due":"20220820124417454","interval":9,"difficulty":1,"stability":16.43780488763927,"retrievability":0.00007617816609952556,"grade":2,"lapses":0,"reps":2,"review":"20220804124417454"}]
interval: 29
lapses: 1
modified: 20220902055617626
reps: 1
retrievability: 0.8303734468904296
review: 20220902055617626
stability: 0.07408182272361549
tags: ?
title: 物化视图
type: text/vnd.tiddlywiki

Materialized views

```
部分高级关系数据库系统提供了一个称为物化视图（Materialized Views) 的特性。
物化视图其实就是一条 SQL 查询，就像常规的虚拟视图 VIEW 一样。但与虚拟视图不同的是，物化视图会缓存查询的结果，因此在请求访问视图时不需要对查询进行重新计算，可以直接获取物化视图的结果，可以认为物化视图其实就是把结果缓存了下来。
举个例子：批处理中，如果以 Hive 天级别的物化视图来说，其实就是每天等数据源 ready 之后，调度物化视图的 SQL 执行然后产生新的结果提供服务。那么就可以认为一条表示了输入、处理、输出的 SQL 就是一个构建物化视图的过程。
映射到我们的流任务中，输入、处理逻辑、输出这一套流程也是一个物化视图的概念。相比批处理来说，流处理中，我们的数据源表的数据是源源不断的。那么从输入、处理、输出的整个物化视图的维护流程也必须是实时的。
因此我们就需要引入一种实时视图维护（Eager View Maintenance）的技术去做到：一旦更新了物化视图的数据源表就立即更新视图的结果，从而保证输出的结果也是最新的。
这种 实时视图维护（Eager View Maintenance）的技术就叫做 连续查询。
```
```
1.	连续查询（Continuous Query） 不断的消费动态输入表的的数据，不断的更新动态结果表的数据。
2.	连续查询（Continuous Query） 的产出的结果 = 批处理模式在输入表的上执行的相同查询的结果。相同的 SQL，对应于同一个输入数据，虽然执行方式不同，但是流处理和批处理的结果是永远都会相同的。

```