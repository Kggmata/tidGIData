created: 20220716130936908
difficulty: 2.0464951521155363
due: 20220831140907802
grade: 0
history: [{"due":"20220727050415710","interval":0,"difficulty":0.07897385645727227,"stability":0.10000011324882507,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220726050415710"},{"due":"20220820123321484","interval":9,"difficulty":1,"stability":16.43780488763927,"retrievability":0.00007617816609952556,"grade":1,"lapses":0,"reps":2,"review":"20220804123321484"}]
interval: 26
lapses: 1
modified: 20220830140907802
reps: 1
retrievability: 0.846495152115536
review: 20220830140907802
stability: 0.07408182272361549
tags: ?
title: 任务（Tasks）和任务槽（Task Slots）
type: text/vnd.tiddlywiki

```
在同一个作业中，并行的子任务是无法放到同一个slot中运行，但是上下游的子任务是可以在同一个slot中运行**

- 任务槽（Task Slots）

  - Flink 中每一个 worker(也就是 TaskManager)都是一个 JVM 进程，它可以启动多个独立的线程，来并行执行多个子任务（subtask）。
  - 所以如果想要执行 5 个任务，并不一定非要 5 个 TaskManager，我们可以让 TaskManager多线程执行任务。如果可以同时运行 5 个线程，那么只要一个 TaskManager 就可以满足我们之前程序的运行需求了。
  - 为了控制并发量，我们需要在 TaskManager 上对每个任务运行所占用的资源做出明确的划分，这就是所谓的任务槽（task slots）。
```
```
每个任务槽（task slot）其实表示了 TaskManager 拥有计算资源的一个固定大小的子集。这些资源就是用来独立执行一个子任务的。
```
[img[image-20220713191007729.png]]

任务槽数量的设置

```
我们可以通过集群的配置文件来设定 TaskManager 的 slot 数量：

- ~~~yaml
  taskmanager.numberOfTaskSlots: 8
  ~~~

- 通过调整 slot 的数量，我们就可以控制子任务之间的隔离级别。

- 具体来说，如果一个 TaskManager 只有一个 slot，那将意味着每个任务都会运行在独立的JVM 中（当然，该 JVM 可能是通过一个特定的容器启动的）；而一个 TaskManager 设置多个slot 则意味着多个子任务可以共享同一个 JVM。它们的区别在于：前者任务之间完全独立运行，隔离级别更高、彼此间的影响可以降到最小；而后者在同一个 JVM 进程中运行的任务，将共享 TCP 连接和心跳消息，也可能共享数据集和数据结构，这就减少了每个任务的运行开销，在降低隔离级别的同时提升了性能。

- **需要注意的是，slot 目前仅仅用来隔离内存，不会涉及 CPU 的隔离。在具体应用时，可以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发环境默认并行度设为机器 CPU 数量的原因**。
```

任务对任务槽的共享
[img[image-20220713191146686.png]]

```
- 默认情况下，Flink 是允许子任务共享 slot 的。

- source/map 尽管是两个算子合并算子链得到的，但它只是基本的数据读取和简单转换，计算耗时极短，一般也不需要太大的内存空间；而 window 算子所做的窗口操作，往往会涉及大量的数据、状态存储和计算，我们一般把这类任务叫作“资源密集型”（intensive）任务。

1. slot共享就是把资源密集型和非密集型任务同时放在一个slot当中, 自行分配资源占用
2. slot共享另一个好处是允许保存完整的作业管道, 这样即便某个TM宕机, 作业的任务可以继续执行

并行子任务不可以共享slot, 因此运行作业所需的slot就是作业所有算子的并行度的最大值

- 当然，Flink 默认是允许 slot 共享的，如果希望某个算子对应的任务完全独占一个 slot，或者只有某一部分算子共享 slot，我们也可以通过设置“slot 共享组”（SlotSharingGroup）手动指定：

.map(word -> Tuple2.of(word, 1L)).slotSharingGroup(“1”);
```
```
- - 这样，只有属于同一个 slot 共享组的子任务，才会开启 slot 共享；不同组之间的任务是完全隔离的，必须分配到不同的 slot 上。在这种场景下，总共需要的 slot 数量，就是各个 slot共享组最大并行度的总和。
```
- 任务槽和并行度的关系

```
简单来说，taskslot 是 静 态 的 概 念 ， 是 指 TaskManager 具 有 的 并 发 执 行 能 力 ， 可 以 通 过 参 数taskmanager.numberOfTaskSlots 进行配置；

并行度（parallelism）是动态概念，也就是TaskManager 运行程序时实际使用的并发能力，
可以通过参数 parallelism.default 进行配置。
换句话说，并行度如果小于等于集群中可用 slot 的总数，程序是可以正常执行的
果并行度大于可用 slot 总数，导致超出了并行能力上限，那么程序就只好等待资源管理器分配更多的资源了。

  - 下面我们再举一个具体的例子。

    - 假设一共有 3 个 TaskManager，每一个TaskManager 中的slot 数量设置为 3 个，那么一共有 9 个 task slot，如下图所示，表示集群最多能并行执行 9个任务。
    - 而我们定义 WordCount 程序的处理操作是四个转换算子：source→ flatMap→ reduce→ sink
    - 当所有算子并行度相同时，容易看出 source 和 flatMap 可以合并算子链，于是最终有三个任务节点。
    - 如果我们没有任何并行度设置，而配置文件中默认 parallelism.default=1，那么程序运行的默认并行度为 1，总共有 3 个任务。由于不同算子的任务可以共享任务槽，所以最终占用的 slot只有 1 个。9 个 slot 只用了 1 个，有 8 个空闲，如下图所示。
```
[img[image-20220713191532621.png]]
[img[image-20220713191537596.png]]
[img[image-20220713191540888.png]]
[img[image-20220713191544132.png]]
[img[image-20220713191547390.png]]

```
- 如果我们更改默认参数，或者提交作业时设置并行度为 2，那么总共有 6 个任务，共享任务槽之后会占用 2 个 slot，如图**示例二**所示。同样，就有 7 个 slot 空闲，计算资源没有充分利用。所以可以看到，设置合适的并行度才能提高效率。
- 那对于这个例子，怎样设置并行度效率最高呢？当然是需要把所有的 slot 都利用起来。考虑到 slot 共享，我们可以直接把并行度设置为 9，这样所有 27 个任务就会完全占用 9 个 slot。这是当前集群资源下能执行的最大并行度，计算资源得到了充分的利用，如图**示例三**所示。
- 另外再考虑对于某个算子单独设置并行度的场景。例如，如果我们考虑到输出可能是写入文件，那会希望不要并行写入多个文件，就需要设置 sink 算子的并行度为 1。这时其他的算子并行度依然为 9，所以总共会有 19 个子任务。根据 slot 共享的原则，它们最终还是会占用全部的 9 个 slot，而 sink 任务只在其中一个 slot 上执行，如图**示例四**所示。通过这个例子也可以明确地看到，整个流处理程序的并行度，就应该是所有算子并行度中最大的那个，这代表了运行程序需要的 slot 数量。
```