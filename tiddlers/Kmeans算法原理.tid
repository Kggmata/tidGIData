created: 20220624084734706
difficulty: 1.065612726934808
due: 20221021055534137
grade: 1
history: [{"due":"20220626051314476","interval":0,"difficulty":0.4015068894836844,"stability":0.1000072479248047,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220625051314476"},{"due":"20220715025420435","interval":4,"difficulty":1,"stability":16.061313745994745,"retrievability":0.014785398243253882,"grade":1,"lapses":0,"reps":2,"review":"20220629025420435"}]
interval: 22
lapses: 0
modified: 20221210005806773
modifier: Yangqing QU
reps: 3
retrievability: 0.865612726934808
review: 20220721055534137
stability: 92.15055392172822
tags: userProfile用户画像 ?
title: Kmeans算法原理
type: text/vnd.tiddlywiki

算法思想: 以空间中k个点为中心进行聚类，对最靠近他们的对象归类。通过迭代的方法，逐次更新各聚类中心的值，直至得到最好的聚类结果

算法输入 数据集

算法输出 聚类结果

算法描述：

（1）随机适当选择c个类的初始中心；
 
（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的中心所在的类；

 [img[BillfishydAkUM2022-06-24 16_53_05.PNG]]

```
arg 是变元（即自变量argument）的英文缩写。 arg min 就是使后面这个式子达到最小值时的变量的取值； arg max 就是使后面这个式子达到最大值时的变量的取值。
```
（3）利用均值等方法更新该类的中心值；
 [img[BillfishANFwyP2022-06-24 16_53_10.PNG]]

（4）对于所有的c个聚类中心，如果利用（2）（3）的迭代法更新后，聚类中心的值保持不变，则迭代结束，否则继续迭代。

[img[BillfishsYPlrA2022-06-24 17_08_35.PNG]]

算法核心步骤：

```
计算距离---归类-----计算均值---距离----归类----均值----距离--.........
（1）求解第i个样本xi到达第j个聚类中心的距离，选择j最小的值赋值给第i个样本的标记值。
（2）对于属于第j个样本的所有的xj求均值，作为第j个样本的新的聚类中心，聚类中心改变了，重新计算标记信息，标记变了重新计算距离。
```
[img[BillfishVGYswx2022-06-24 17_09_44.PNG]]

   输入：k, data[n];

```
（1） 选择k个初始中心点，例如c[0]=data[0],…c[k-1]=data[k-1];
       （2） 对于data[0]….data[n], 分别与c[0]…c[k-1]比较，假定与c[i]差值最少，就标记为i;
       （3） 对于所有标记为i点，重新计算c[i]={ 所有标记为i的data[j]之和}/标记为i的个数；
      （4） 重复(2)(3),直到所有c[i]值的变化小于给定阈值。
```
[img[BillfishRnRpbT2022-06-24 17_10_13.PNG]]

通过下面的例子理解上面的算法迭代过程。
示例：假设我们有4个对象作为训练数据点，每个对象有2个属性。 每个属性表示对象的一个维度的坐标。

